# BinaryFileFormat (leave this tag as its own magic token!)

# Analyze img/hdr Header format
#
# Version:  v1.1
# Build:    16012320
# Date:     Jan-23 2016, 8:36 PM EST
# Editor:   Jochen Weber, SCAN Unit, Columbia University, NYC, NY, USA
# URL/Info: http://neuroelf.net/

# FILE FORMAT
DefaultProperty:VoxelData
Description:Analyze header files,NIftI header files
EncodingSyntax:ieee-le
Extensions:hdr,nii
Magic:|
name             |range       |type    |magic
HDR_AnalyzeBE    |  1,   7    |hex     |00, 00, 01, 5c, 64, 73, 72
HDR_AnalyzeLE    |  1,   7    |hex     |5c, 01, 00, 00, 64, 73, 72
HDR_NiFTiMagic   |345, 348    |hex     |6e, 69, 69, 00
HDR_NiFTiMagic_1 |345, 348    |hex     |6e, 69, 31, 00
HDR_NiFTiMagic_pp|345, 348    |hex     |6e, 2b, 31, 00
EndMagic

# FIELDS
ListOfFields:!
type  !cond                   !disktype!datatype!dim                      !default !varname

# setup before reading
EXPRE !$BFFREAD           !!!!!eval(bffspec.NewFileCode);

# correctly handle fixed length strings
EXPRE !$BFFWRITE          !!!!!...
if @NIIFileType == 1, ...
    @FileMagic = 'ni1'; ...
elseif @NIIFileType > 1, ...
    @FileMagic = 'n+1'; ...
end, ...
@HdrKey.DataType = zerodstring(@HdrKey.DataType, 10); ...
@HdrKey.DBName = zerodstring(@HdrKey.DBName, 18); ...
try, ...
    @HdrKey.Regular = @HdrKey.Regular(1); ...
catch ne_eo; ...
    neuroelf_lasterr(ne_eo); ...
    @HdrKey.Regular = 'r'; ...
end, ...
@ImgDim.Dim = [4, 1, 1, 1, 1, 0, 0, 0]; ...
if ~any(@ImgDim.DataType == [128, 2304]), ...
    $ndi = ndims(@VoxelData); ...
    @ImgDim.Dim(2:1+ndims(@VoxelData)) = size(@VoxelData); ...
else, ...
    $ndisz = size(@VoxelDataRGBA); ...
    if any($ndisz(end) == [3, 4]), ...
        $ndisz(end) = []; ...
    end, ...
    while $ndisz(end) == 1, ...
        $ndisz(end) = []; ...
    end, ...
    $ndi = numel($ndisz); ...
    @ImgDim.Dim(2:1+$ndi) = $ndisz; ...
    @ImgDim.Dim(1) = $ndi; ...
end, ...
if $ndi > 4, ...
    @ImgDim.Dim(1) = $ndi; ...
end, ...
@DataHist.Description = zerodstring(@DataHist.Description, 80); ...
@DataHist.AuxFilename = zerodstring(@DataHist.AuxFilename, 24); ...
try, ...
    @DataHist.Orientation = @DataHist.Orientation(1); ...
catch ne_eo; ...
    neuroelf_lasterr(ne_eo); ...
    @DataHist.Orientation = int8(0); ...
end, ...
if numel(@DataHist.OriginString) > 5, ...
    @DataHist.Originator = uint8(@DataHist.OriginString), ...
elseif numel(@DataHist.OriginSPM) == 5 && ~all(@DataHist.OriginSPM == 0), ...
    dh = min(32767, max(-32768, round(@DataHist.OriginSPM(:)'))); ...
    dh(dh < 0) = dh(dh < 0) + 65536; ...
    @DataHist.Originator = [uint8(floor(dh / 256)); uint8(mod(dh, 256))]; ...
    if strcmpi(@Endian, 'ieee-le'), ...
        @DataHist.Originator = @DataHist.Originator([2,1], :); ...
    end, ...
    @DataHist.Originator = @DataHist.Originator(:)'; ...
end, ...
@DataHist.Generated = zerodstring(@DataHist.Generated, 10); ...
@DataHist.ScanNumber = zerodstring(@DataHist.ScanNumber, 10); ...
@DataHist.PatientID = zerodstring(@DataHist.PatientID, 10); ...
@DataHist.ExpiryDate = zerodstring(@DataHist.ExpiryDate, 10); ...
@DataHist.ExpiryTime = zerodstring(@DataHist.ExpiryTime, 10); ...
@DataHist.Hist_UN0 = zerodstring(@DataHist.Hist_UN0, 3); ...
@DataHist.NIftI1.IntentName = zerodstring(@DataHist.NIftI1.IntentName, 16); ...
@IntermedData = @IntermedData(:)'; ...
$IntermediateData = numel(@IntermedData);

# Header fields in HdrKey

# assume le for reading, and re-open file for writing if endian is not ieee-le
EXPRE !!!!!! ...
if $BFFREAD, ...
    @Endian = 'ieee-le'; ...
    fseek(fid, 344, -1); ...
    if ftell(fid) ~= 344, ...
        error('FILE_TOO_SHORT'); ...
    end, ...
    @FileMagic = unzerostring(fread(fid, [1, 4], '*char')); ...
    fseek(fid, 0, -1); ...
else, ...
    if isempty(strfind(lower(@Endian), 'ieee-le')), ...
        fclose(fid); ...
        fid = fopen([$FILENAME '.tmp'], 'w', 'ieee-be'); ...
    end, ...
end, ...
switch(@FileMagic), ...
    case{'ni1', 'nii'}, ...
        @NIIFileType = 1; ...
    case {'n+1'}, ...
        @NIIFileType = 2; ...
    otherwise, ...
        @NIIFileType = 0; ...
        @FileMagic = 'ni0'; ...
end, ...
if $BFFWRITE && @NIIFileType == 2, ...
    @ImgDim.VoxOffset = max(@ImgDim.VoxOffset, 348 + numel(@IntermedData)); ...
end

# check endian type, and maybe re-open file
FIELD !                       !uint32  !double  !1, 1                     !348     !HdrKey.SizeOfHdr      # 0x0000, 348
EXPRE !$BFFREAD           !!!!!...
if @HdrKey.SizeOfHdr > 16777216, ...
    fclose(fid); ...
    fid = fopen($FILENAME, 'r', 'ieee-be'); ...
    fseek(fid, 0, -1); ...
    @HdrKey.SizeOfHdr = double(fread(fid, [1, 1], '*uint32')); ...
    if @HdrKey.SizeOfHdr > 16777216, ...
        error('BAD_ANALYZE_FILE'); ...
    end, ...
    @Endian = 'ieee-be'; ...
end

# other header fields
FIELD !                       !char    !char    !1, 10                    !        !HdrKey.DataType       # 0x0004, 'dsr' + \0 * 7
FIELD !                       !char    !char    !1, 18                    !        !HdrKey.DBName         # 0x000e, ''    + \0 * 18
FIELD !                       !int32   !double  !1, 1                     !0       !HdrKey.Extents        # 0x0020, 0
FIELD !                       !int16   !double  !1, 1                     !0       !HdrKey.SessionError   # 0x0024, 0
FIELD !                       !char    !char    !1, 1                     !0       !HdrKey.Regular        # 0x0026, 0
FIELD !                       !int8    !int8    !1, 1                     !0       !HdrKey.SliceOrdering  # 0x0027, 0 (NIfTi-1: MRI slice ordering)

# Header fields in ImageDimension
FIELD !                       !int16   !double  !1, 8                     !        !ImgDim.Dim            # 0x0028, e.g. [4 64 64 30 1 0 0 0]
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.IntentParam1   # 0x0038, ...
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.IntentParam2   # 0x003c, ...
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.IntentParam3   # 0x0040, ...
FIELD !                       !int16   !double  !1, 1                     !0       !ImgDim.IntentCode     # 0x0044, ...
FIELD !                       !int16   !double  !1, 1                     !4       !ImgDim.DataType       # 0x0046, 4
FIELD !                       !uint16  !double  !1, 1                     !16      !ImgDim.BitsPerPixel   # 0x0048, 16
FIELD !                       !int16   !double  !1, 1                     !0       !ImgDim.FirstSliceIndex# 0x004a, 0 (NIfTI-1: Slice start)
FIELD !                       !single  !double  !1, 8                     !        !ImgDim.PixSpacing     # 0x004c, e.g. [0 3 3 3.5 0 0 0 0]
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.VoxOffset      # 0x006c, 0 (348+ for n+1)
FIELD !                       !single  !double  !1, 1                     !1       !ImgDim.ScalingSlope   # 0x0070, 0
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.ScalingIntercept#0x0074, 0
FIELD !                       !int16   !double  !1, 1                     !0       !ImgDim.LastSliceIndex # 0x0078, 0
FIELD !                       !int8    !int8    !1, 1                     !0       !ImgDim.SliceTimeOrder # 0x007a, 0
FIELD !                       !int8    !int8    !1, 1                     !2       !ImgDim.NIftIUnits      # 0x007b, 0
FIELD !                       !single  !double  !1, 1                     !32767   !ImgDim.CalMaxDisplay  # 0x007c, 32767
FIELD !                       !single  !double  !1, 1                     !-32768  !ImgDim.CalMinDisplay  # 0x0080, -32768
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.SliceDuration  # 0x0084, 0
FIELD !                       !single  !double  !1, 1                     !0       !ImgDim.SliceTimeOffset# 0x0088, 0
FIELD !                       !int32   !double  !1, 1                     !32767   !ImgDim.GLMax          # 0x008c, 32767
FIELD !                       !int32   !double  !1, 1                     !-32768  !ImgDim.GLMin          # 0x0090, -32768
FIELD !                       !char    !char    !1, 80                    !        !DataHist.Description  # 0x0094, '' + \0 * 80
FIELD !                       !char    !char    !1, 24                    !        !DataHist.AuxFilename  # 0x00e4, '' + \0 * 24
EXPRE !!!!!!...
@HdrKey.DataType = unzerostring(@HdrKey.DataType); ...
@HdrKey.DBName = unzerostring(@HdrKey.DBName); ...
if @ImgDim.ScalingSlope == 0, ...
    @ImgDim.ScalingSlope = 1; ...
end, ...
@DataHist.Description = unzerostring(@DataHist.Description); ...
@DataHist.AuxFilename = unzerostring(@DataHist.AuxFilename);

# # # # # ANALYZE 7.5 START # # # # #

# header fields for DataHistory (Analyze75)
BLOOP !@NIIFileType < 1       ! ! !1 ! !Analyze75
FIELD !                       !int8    !int8    !1, 1                     !        !DataHist.Orientation  # 0x00fc, 'n'
FIELD !                       !uint8   !uint8   !1, 10                    !        !DataHist.Originator   # 0x00fd
FIELD !                       !char    !char    !1, 10                    !        !DataHist.Generated    # 0x0107, '' + \0 * 10
FIELD !                       !char    !char    !1, 10                    !        !DataHist.ScanNumber   # 0x0111, '' + \0 * 10
FIELD !                       !char    !char    !1, 10                    !        !DataHist.PatientID    # 0x011b, '' + \0 * 10
FIELD !                       !char    !char    !1, 10                    !        !DataHist.ExpiryDate   # 0x0125, '' + \0 * 10
FIELD !                       !char    !char    !1, 10                    !        !DataHist.ExpiryTime   # 0x012f, '' + \0 * 10
FIELD !                       !char    !char    !1, 3                     !        !DataHist.Hist_UN0     # 0x0139, '' + \0 * 3

# correctly handle fixed length strings
EXPRE !!!!!!...
if strcmpi(@Endian, 'ieee-le'), ...
    @DataHist.OriginSPM = 256 * double(@DataHist.Originator(2:2:end)) + double(@DataHist.Originator(1:2:end)); ...
else, ...
    @DataHist.OriginSPM = 256 * double(@DataHist.Originator(1:2:end)) + double(@DataHist.Originator(2:2:end)); ...
end, ...
if mod(@DataHist.OriginSPM(end), 4096) ~= 0, ...
    @DataHist.OriginSPM = zeros(size(@DataHist.OriginSPM)); ...
end, ...
@DataHist.OriginSPM(@DataHist.OriginSPM > 32767) = @DataHist.OriginSPM(@DataHist.OriginSPM > 32767) - 65536; ...
@DataHist.OriginString = unzerostring(char(@DataHist.Originator)); ...
@DataHist.Generated = unzerostring(@DataHist.Generated); ...
@DataHist.ScanNumber = unzerostring(@DataHist.ScanNumber); ...
@DataHist.PatientID = unzerostring(@DataHist.PatientID); ...
@DataHist.ExpiryDate = unzerostring(@DataHist.ExpiryDate); ...
@DataHist.ExpiryTime = unzerostring(@DataHist.ExpiryTime); ...
@DataHist.Hist_UN0 = unzerostring(@DataHist.Hist_UN0);

# remaining fixed fields
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.Views        # 0x013c, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.VolumesAdded # 0x0140, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.StartField   # 0x0144, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.FieldSkip    # 0x0148, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.OMax         # 0x014c, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.OMin         # 0x0150, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.SMax         # 0x0154, 0
FIELD !                       !int32   !double  !1, 1                     !        !DataHist.SMin         # 0x0158, 0  [length: 0x15c = 348 bytes]
ELOOP !                       ! ! !  ! !Analyze75

# # # # # ANALYZE 7.5 / NIFTI BREAK # # # # #

# header fields for DataHistory (NIftI: nii, ni1, n+1)
BLOOP !@NIIFileType >= 1      ! ! !1 ! !NiftiHeader
EXPRE !                   !!!!!@FileMagic = zerodstring(@FileMagic, 4);
FIELD !                       !int16   !double  !1, 1                     !        !DataHist.NIftI1.QFormCode         # 0x00fc, ...
FIELD !                       !int16   !double  !1, 1                     !        !DataHist.NIftI1.SFormCode         # 0x00fe, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuaternionB       # 0x0100, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuaternionC       # 0x0104, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuaternionD       # 0x0108, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuatOffsetX       # 0x010c, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuatOffsetY       # 0x0110, ...
FIELD !                       !single  !double  !1, 1                     !        !DataHist.NIftI1.QuatOffsetZ       # 0x0114, ...
FIELD !                       !single  !double  !1, 4                     !        !DataHist.NIftI1.AffineTransX      # 0x0118, ...
FIELD !                       !single  !double  !1, 4                     !        !DataHist.NIftI1.AffineTransY      # 0x0128, ...
FIELD !                       !single  !double  !1, 4                     !        !DataHist.NIftI1.AffineTransZ      # 0x0138, ...
FIELD !                       !char    !char    !1, 16                    !        !DataHist.NIftI1.IntentName        # 0x0148, '' + \0 * 16
FIELD !                       !char    !char    !1, 4                     !        !FileMagic                         # 0x0158, 'ni1' + \0  **OR** 'n+1' + \0
EXPRE !$BFFREAD           !!!!!$IntermediateData = @ImgDim.VoxOffset - 348; @IntermedData = uint8([]);
FIELD !$IntermediateData > 0  !uint8   !uint8   !1, $IntermediateData     !        !IntermedData      # 0x015c, []

# correctly handle fixed length strings
EXPRE !!!!!!...
@DataHist.Description = unzerostring(@DataHist.Description); ...
@DataHist.AuxFilename = unzerostring(@DataHist.AuxFilename); ...
@DataHist.NIftI1.IntentName = unzerostring(@DataHist.NIftI1.IntentName); ...
@FileMagic = unzerostring(@FileMagic);
ELOOP !                       ! ! !  ! !NiftiHeader

# # # # # NIFTI END # # # # #

# voxel data of older formats as direct transio
EXPRE !!!!!!...
$dsize = @ImgDim.Dim(2:@ImgDim.Dim(1) + 1); ...
if numel($dsize) == 1, ...
    $dsize(2) = 1; ...
end, ...
$dtypes = false; ...
try, ...
    if @ImgDim.DataType <= 256 || any(@ImgDim.DataType == (256:256:2304)), ...
        $dtype = @ImgDim.DataType; ...
    else, ...
        $dtype = fix(@ImgDim.DataType / 256); ...
    end, ...
    switch ($dtype), case {2}, ...
        $dtype = 'uint8'; ...
        $dtypef = 1; ...
    case {4}, ...
        $dtype = 'int16'; ...
        $dtypef = 2; ...
    case {8}, ...
        $dtype = 'int32'; ...
        $dtypef = 4; ...
    case {16}, ...
        $dtype = 'single'; ...
        $dtypef = 4; ...
    case {32}, ...
        $dtype = 'csingle'; ...
        $dtypef = 8; ...
        $dtypes = true; ...
    case {64}, ...
        $dtype = 'double'; ...
        $dtypef = 8; ...
    case {128}, ...
        $dtype = 'rgb'; ...
        $dtypes = true; ...
        $dtypef = 3; ...
    case {130, 256}, ...
        $dtype = 'int8'; ...
        $dtypef = 1; ...
    case {132, 512}, ...
        $dtype = 'uint16'; ...
        $dtypef = 2; ...
    case {136, 768}, ...
        $dtype = 'uint32'; ...
        $dtypef = 4; ...
    case {1024}, ...
        $dtype = 'int64'; ...
        $dtypef = 8; ...
    case {1280}, ...
        $dtype = 'uint64'; ...
        $dtypef = 8; ...
    case {1536}, ...
        $dtype = 'ldouble'; ...
        $dtypef = 16; ...
        $dtypes = true; ...
    case {1792}, ...
        $dtype = 'cdouble'; ...
        $dtypef = 16; ...
        $dtypes = true; ...
    case {2048}, ...
        $dtype = 'cldouble'; ...
        $dtypef = 32; ...
        $dtypes = true; ...
    case {2304}, ...
        $dtype = 'rgba'; ...
        $dtypef = 4; ...
        $dtypes = true; ...
    otherwise, ...
        error('BAD_DATATYPE'); ...
    end, ...
catch ne_eo; ...
    neuroelf_lasterr(ne_eo); ...
    $dtype = ''; ...
end

# skip read if header only
EXPRE !$HEADERONLY        !!!!!fseek(fid, 0, 1); rulec = 999;

# read (transio access) data
EXPRE !$BFFREAD           !!!!!...
try, ...
    if @NIIFileType < 2, ...
        [text{1:3}] = fileparts($FILENAME); ...
        if any(text{3}(2:end) == upper(text{3}(2:end))), ...
            timfile = [text{1} '/' text{2} '.IMG']; ...
        else, ...
            timfile = [text{1} '/' text{2} '.img']; ...
        end, ...
    else, ...
        oldfpos = ftell(fid); ...
        fseek(fid, 0, 1); ...
        maxfpos = ftell(fid); ...
        fclose(fid); ...
        timfile = $FILENAME; ...
        if numel($dsize) == 4, ...
            $dsize4 = min($dsize(4), floor((maxfpos - @ImgDim.VoxOffset) / (prod($dsize(1:3)) * $dtypef))); ...
            if $dsize4 ~= $dsize(4), ...
                $dsize(4) = $dsize4; ...
                warning('Incomplete NII file.'); ...
            end, ...
        end, ...
    end, ...
catch ne_eo; ...
    rethrow(ne_eo); ...
end, ...
try, ...
    if ~$dtypes, ...
        try, ...
            @VoxelData = transio(timfile, @Endian, $dtype, @ImgDim.VoxOffset, $dsize); ...
        end, ...
        if @NIIFileType > 1, ...
            oldfpos = oldfpos + $dtypef * prod(size(@VoxelData)); ...
            fid = fopen($FILENAME, 'r', @Endian); ...
            fseek(fid, oldfpos, -1); ...
        end, ...
        if ~isempty(@VoxelData), ...
            @VoxelDataCT = cell(1, size(@VoxelData, 4)); ...
            @RunTimeVars.Map = @RunTimeVars.Map(ones(1, numel(@VoxelDataCT))); ...
            for hmc = 1:numel(@VoxelDataCT), ...
                @RunTimeVars.Map(hmc).Name = sprintf('%s - map %d', @DataHist.Description, hmc); ...
            end, ...
        end, ...
    else, ...
        timfid = fopen(timfile, 'r', @Endian); ...
        fseek(timfid, @ImgDim.VoxOffset, -1); ...
        switch ($dtype), ...
            case {'csingle'}, ...
                @VoxelData = reshape(fread(timfid, [1, prod([2, $dsize])], '*single'), [2, $dsize]); ...
                @VoxelDataComplex = squeeze(@VoxelData(2, :, :, :, :, :, :, :, :)); ...
                @VoxelData = squeeze(@VoxelData(1, :, :, :, :, :, :, :, :)); ...
            case {'cdouble'}, ...
                @VoxelData = reshape(fread(timfid, [1, prod([2, $dsize])], '*double'), [2, $dsize]); ...
                @VoxelDataComplex = squeeze(@VoxelData(2, :, :, :, :, :, :, :, :)); ...
                @VoxelData = squeeze(@VoxelData(1, :, :, :, :, :, :, :, :)); ...
            case {'rgb'}, ...
                @VoxelDataRGBA = reshape(fread(timfid, [1, prod([3, $dsize])], '*uint8'), [3, $dsize]); ...
                @VoxelDataRGBA = permute(@VoxelDataRGBA, [2:max(5, ndims(@VoxelDataRGBA)), 1]); ...
            case {'rgba'}, ...
                @VoxelDataRGBA = reshape(fread(timfid, [1, prod([4, $dsize])], '*uint8'), [4, $dsize]); ...
                @VoxelDataRGBA = permute(@VoxelDataRGBA, [2:max(5, ndims(@VoxelDataRGBA)), 1]); ...
            otherwise, ...
                error(['Not yet supported datatype: ' $dtype]); ...
        end, ...
        fclose(timfid); ...
        if @NIIFileType > 1, ...
            oldfpos = oldfpos + $dtypef * prod($dsize); ...
            fid = fopen($FILENAME, 'r', @Endian); ...
            fseek(fid, oldfpos, -1); ...
        end, ...
    end, ...
catch ne_eo; ...
    warning(ne_eo.message); ...
end

# update transio access and/or write data
EXPRE !$BFFWRITE          !!!!!...
if ~$dtypes, ...
    if (~isempty(@VoxelData) && isnumeric(@VoxelData) && ~isempty($dtype)), ...
        try, ...
            if @NIIFileType < 2, ...
                oldfpos = -1; ...
                [text{1:3}] = fileparts($FILENAME); ...
                if any(text{3}(2:end) == upper(text{3}(2:end))), ...
                    timfile = [text{1} '/' text{2} '.IMG']; ...
                else, ...
                    timfile = [text{1} '/' text{2} '.img']; ...
                end, ...
            else, ...
                oldfpos = ftell(fid); ...
                timfile = $FILENAME; ...
            end, ...
            if istransio(@VoxelData) && ...
               (iscell(filename(@VoxelData)) || ...
                ~strcmpi(strrep(filename(@VoxelData), '\', '/'), strrep(timfile, '\', '/')) || ...
                @NIIFileType > 1), ...
                tiostr = struct(@VoxelData); ...
                if @NIIFileType < 2, ...
                    if exist(timfile, 'file') ~= 2, ...
                        opmode = 'w'; ...
                    else, ...
                        opmode = 'r+'; ...
                    end, ...
                    nfid = fopen(timfile, opmode, @Endian); ...
                    if @ImgDim.VoxOffset > 0, ...
                        try, ...
                            fseek(fid, @ImgDim.VoxOffset, -1); ...
                        end, ...
                    end, ...
                    nfpos = ftell(nfid); ...
                    if nfpos < @ImgDim.VoxOffset, ...
                        fseek(nfid, 0, 1); ...
                        fwrite(nfid, uint8(zeros(1, @ImgDim.VoxOffset - ftell(nfid))), 'uint8'); ...
                    end, ...
                else, ...
                    ofpos = ftell(fid); ...
                    if ofpos > @ImgDim.VoxOffset, ...
                        @ImgDim.VoxOffset = ofpos; ...
                    else, ...
                        fwrite(fid, uint8(zeros(1, @ImgDim.VoxOffset - ofpos)), 'uint8'); ...
                    end, ...
                    nfid = fid; ...
                end, ...
                tiofname = tiostr.FileName; ...
                if ~iscell(tiofname), ...
                    tiofname = {tiofname}; ...
                else, ...
                    tiostr.DataDims(end) = []; ...
                end, ...
                tiointype = tiostr.DataType; ...
                try, ...
                    for tiofcnt = 1:numel(tiofname), ...
                        tiofile = -1; ...
                        if tiostr.LittleND, ...
                            tiofile = fopen(tiofname{tiofcnt}, 'r', 'ieee-le'); ...
                        else, ...
                            tiofile = fopen(tiofname{tiofcnt}, 'r', 'ieee-be'); ...
                        end, ...
                        tionumpos = prod(tiostr.DataDims); ...
                        tioendpos = tiostr.IOOffset(tiofcnt) + tiostr.TypeSize * tionumpos; ...
                        fseek(tiofile, tioendpos, -1); ...
                        if ftell(tiofile) ~= tioendpos, ...
                            error('bad transio file.'); ...
                        end, ...
                        fseek(tiofile, tiostr.IOOffset(tiofcnt), -1); ...
                        while tionumpos > 1048576, ...
                            fwrite(nfid, fread(tiofile, [1, 1048576], [tiointype '=>double']), $dtype); ...
                            tionumpos = tionumpos - 1048576; ...
                        end, ...
                        fwrite(nfid, fread(tiofile, [1, tionumpos], [tiointype '=>double']), $dtype); ...
                        fclose(tiofile); ...
                    end, ...
                catch ne_eo; ...
                    if tiofile > 0, ...
                        fclose(tiofile); ...
                        if @NIIFileType < 2, ...
                            fclose(nfid); ...
                        end, ...
                        rethrow(ne_eo); ...
                    else, ...
                        neuroelf_lasterr(ne_eo); ...
                    end, ...
                end, ...
                if @NIIFileType < 2, ...
                    fclose(nfid); ...
                    try, ...
                        @VoxelData = transio(timfile, @Endian, $dtype, @ImgDim.VoxOffset, $dsize); ...
                    catch ne_eo; ...
                        neuroelf_lasterr(ne_eo); ...
                        warning('transio re-open failed.'); ...
                        @VoxelData = []; ...
                    end, ...
                else, ...
                    fseek(nfid, ofpos, -1); ...
                    tiostr.FileName = timfile; ...
                    tiostr.IOOffset = @ImgDim.VoxOffset; ...
                    tiostr.DataDims = $dsize; ...
                    try, ...
                        @VoxelData = transio(0, 'makeobject', tiostr); ...
                    catch ne_eo; ...
                        neuroelf_lasterr(ne_eo); ...
                        warning('transio re-open failed.'); ...
                        @VoxelData = []; ...
                    end, ...
                end, ...
            elseif ~istransio(@VoxelData), ...
                if @NIIFileType == 2, ...
                    ofpos = ftell(fid); ...
                    if ofpos > @ImgDim.VoxOffset, ...
                        @ImgDim.VoxOffset = ofpos; ...
                    elseif ofpos < @ImgDim.VoxOffset, ...
                        fwrite(fid, uint8(zeros(1, @ImgDim.VoxOffset - ofpos)), 'uint8'); ...
                    end, ...
                    fwrite(fid, @VoxelData, $dtype); ...
                else, ...
                    nfid = fopen(timfile, 'w', @Endian); ...
                    if @ImgDim.VoxOffset > 0, ...
                        fwrite(nfid, uint8(zeros(1, @ImgDim.VoxOffset)), 'uint8'); ...
                    end, ...
                    fwrite(nfid, @VoxelData, $dtype); ...
                    fclose(nfid); ...
                end, ...
            else, ...
                tiostr = struct(@VoxelData); ...
                if tiostr.IOOffset ~= @ImgDim.VoxOffset || ~strcmpi($dtype, tiostr.DataType), ...
                    error('Invalid transio re-use'); ...
                end, ...
            end, ...
        end, ...
    end, ...
else, ...
    try, ...
        if @NIIFileType < 2, ...
            oldfpos = -1; ...
            [text{1:3}] = fileparts($FILENAME); ...
            if any(text{3}(2:end) == upper(text{3}(2:end))), ...
                timfile = [text{1} '/' text{2} '.IMG']; ...
            else, ...
                timfile = [text{1} '/' text{2} '.img']; ...
            end, ...
            nfid = fopen(timfile, 'w', @Endian); ...
            if @ImgDim.VoxOffset > 0, ...
                fwrite(nfid, uint8(zeros(1, @ImgDim.VoxOffset)), 'uint8'); ...
            end, ...
        else, ...
            oldfpos = ftell(fid); ...
            timfile = $FILENAME; ...
            ofpos = ftell(fid); ...
            if ofpos > @ImgDim.VoxOffset, ...
                @ImgDim.VoxOffset = ofpos; ...
            elseif ofpos < @ImgDim.VoxOffset, ...
                fwrite(fid, uint8(zeros(1, @ImgDim.VoxOffset - ofpos)), 'uint8'); ...
            end, ...
        end, ...
        switch ($dtype), ...
            case {'csingle', 'cdouble'}, ...
                csddata = cat(1, shiftdim(@VoxelData, -1), shiftdim(@VoxelDataComplex, -1)); ...
                fwrite(fid, csddata, $dtype(2:end)); ...
            case {'rgb', 'rgba'}, ...
                rgbdata = permute(@VoxelDataRGBA, [ndims(@VoxelDataRGBA), 1:(ndims(@VoxelDataRGBA)-1)]); ...
                fwrite(fid, rgbdata, 'uint8'); ...
        end, ...
        if @NIIFileType < 2, ...
            fclose(nfid); ...
        end, ...
    catch ne_eo, ...
    end, ...
end

# read/write of MAT file for 4x4 transformation
EXPRE !$BFFREAD           !!!!!...
try, ...
    $matname = regexprep($FILENAME, '\.(hdr|nii)$', '.mat', 'preservecase'); ...
    if exist($matname, 'file') == 2, ...
        $matcont = load($matname); ...
        if isfield($matcont, 'mat'), ...
            @RunTimeVars.Mat44 = $matcont.mat; ...
        elseif isfield($matcont, 'M'), ...
            @RunTimeVars.Mat44 = $matcont.M; ...
        end, ...
    end, ...
end
EXPRE !$BFFWRITE          !!!!!...
try, ...
    if isequal(size(@RunTimeVars.Mat44), [4, 4, 1]) || ...
        isequal(size(@RunTimeVars.Mat44), [4, 4, size(@VoxelData, 4)]), ...
        try, ...
            $matname = regexprep($FILENAME, '\.(hdr|nii)$', '.mat', 'preservecase'); ...
            if exist($matname, 'file') == 2, ...
                $matcont = load($matname); ...
                if isfield($matcont, 'mat'), ...
                    $matcont.mat = @RunTimeVars.Mat44; ...
                end, ...
                if isfield($matcont, 'M'), ...
                    $matcont.M = @RunTimeVars.Mat44; ...
                end, ...
            elseif size(@RunTimeVars.Mat44, 3) > 1 || ...
                @NIIFileType == 0, ...
                $matcont = struct('mat', @RunTimeVars.Mat44, 'M', @RunTimeVars.Mat44); ...
            else, ...
                $matcont = []; ...
            end, ...
        catch ne_eo; ...
            neuroelf_lasterr(ne_eo); ...
            $matcont = struct('mat', @RunTimeVars.Mat44, 'M', @RunTimeVars.Mat44); ...
        end, ...
        if ~isempty($matcont), ...
            writemat($matname, '-v6', fieldnames($matcont), struct2cell($matcont)); ...
        end, ...
    end, ...
end

# read/write b-vals and b-vecs
EXPRE !$BFFREAD           !!!!!...
try, ...
    $bvalname = regexprep($FILENAME, '\.(hdr|nii)$', '.bval'); ...
    $bvecname = regexprep($FILENAME, '\.(hdr|nii)$', '.bvec'); ...
    if exist($bvalname, 'file') == 2 && ...
        exist($bvecname, 'file') == 2, ...
        $bvalcont = u8str2double(binread($bvalname), 1, size(@VoxelData, 4))'; ...
        $bveccont = u8str2double(binread($bvecname), 3, size(@VoxelData, 4))'; ...
        @RunTimeVars.BVals = $bvalcont; ...
        @RunTimeVars.BVecs = $bveccont; ...
    end, ...
end
EXPRE !$BFFWRITE          !!!!!...
try, ...
    if isfield(@RunTimeVars, 'BVals') && ...
        isa(@RunTimeVars.BVals, 'double') && ...
        isequal(size(@RunTimeVars.BVals), [size(@VoxelData, 4), 1]) && ...
        isfield(@RunTimeVars, 'BVecs') && ...
        isa(@RunTimeVars.BVecs, 'double') && ...
        isequal(size(@RunTimeVars.BVecs), [size(@VoxelData, 4), 3]), ...
        $bvalname = regexprep($FILENAME, '\.(hdr|nii)$', '.bval'); ...
        $bvecname = regexprep($FILENAME, '\.(hdr|nii)$', '.bvec'); ...
        if ~strcmpi($bvalname, $FILENAME) && ...
           ~strcmpi($bvecname, $FILENAME), ...
            $bvalcont = [sprintf('%d ', @RunTimeVars.BVals'), char(10)]; ...
            $bveccont = sprintf([repmat('%.14g ', 1, size(@VoxelData, 4)), char(10)], @RunTimeVars.BVecs(:)'); ...
            binwrite($bvalname, uint8($bvalcont)); ...
            binwrite($bvecname, uint8($bveccont)); ...
        end, ...
    end, ...
end

# that's all folks
EndListOfFields

NewFileCode:!
@Endian = 'ieee-le';
@FileMagic = 'n+1';
@NIIFileType = 2;
@HdrKey.SizeOfHdr = 348;
@HdrKey.DataType = 'dsr';
@HdrKey.DBName = '';
@HdrKey.Extents = 0;
@HdrKey.SessionError = 0;
@HdrKey.Regular = 'r';
@HdrKey.SliceOrdering = int8(0);
@ImgDim.Dim = [4, 0, 0, 0, 1, 0, 0, 0];
@ImgDim.IntentParam1 = 0;
@ImgDim.IntentParam2 = 0;
@ImgDim.IntentParam3 = 0;
@ImgDim.IntentCode = 0;
@ImgDim.DataType = 4;
@ImgDim.BitsPerPixel = 16;
@ImgDim.FirstSliceIndex = 0;
@ImgDim.PixSpacing = [0, 1, 1, 1, 1, 0, 0, 0];
@ImgDim.VoxOffset = 352;
@ImgDim.ScalingSlope = 1;
@ImgDim.ScalingIntercept = 0;
@ImgDim.LastSliceIndex = 0;
@ImgDim.SliceTimeOrder = int8(0);
@ImgDim.NIftIUnits = int8(0);
@ImgDim.CalMaxDisplay = 32767;
@ImgDim.CalMinDisplay = -32768;
@ImgDim.SliceDuration = 0;
@ImgDim.SliceTimeOffset = 0;
@ImgDim.GLMax = 32767;
@ImgDim.GLMin = -32768;
@DataHist.Description = 'New image created with NeuroElf/xff';
@DataHist.AuxFilename = '';
@DataHist.Orientation = int8(0);
@DataHist.Originator = uint8(zeros(1, 10));
@DataHist.OriginSPM = zeros(1, 5);
@DataHist.OriginString = '';
@DataHist.Generated = '';
@DataHist.ScanNumber = '';
@DataHist.PatientID = '';
@DataHist.ExpiryDate = '';
@DataHist.ExpiryTime = '';
@DataHist.Hist_UN0 = '';
@DataHist.Views = 0;
@DataHist.VolumesAdded = 0;
@DataHist.StartField = 0;
@DataHist.FieldSkip = 0;
@DataHist.OMax = 0;
@DataHist.OMin = 0;
@DataHist.SMax = 0;
@DataHist.SMin = 0;
@DataHist.NIftI1 = struct;
@DataHist.NIftI1.QFormCode = 3;
@DataHist.NIftI1.SFormCode = 3;
@DataHist.NIftI1.QuaternionB = 0;
@DataHist.NIftI1.QuaternionC = 0;
@DataHist.NIftI1.QuaternionD = 0;
@DataHist.NIftI1.QuatOffsetX = 0;
@DataHist.NIftI1.QuatOffsetY = 0;
@DataHist.NIftI1.QuatOffsetZ = 0;
@DataHist.NIftI1.AffineTransX = [1, 0, 0, 0];
@DataHist.NIftI1.AffineTransY = [0, 1, 0, 0];
@DataHist.NIftI1.AffineTransZ = [0, 0, 1, 0];
@DataHist.NIftI1.IntentName = '';
@IntermedData = uint8([0, 0, 0, 0]);
@VoxelData = int16(zeros(@ImgDim.Dim(2:1+@ImgDim.Dim(1))));
@VoxelDataComplex = [];
@VoxelDataRGBA = [];
@VoxelDataCT = {};
@RunTimeVars = struct( ...
    'BVals', [], ...
    'BVecs', zeros(0, 3), ...
    'Discard', [], ...
    'History', {{}}, ...
    'Info', '', ...
    'Map', repmat(struct( ...
        'Type', 0, 'LowerThreshold', 3, 'UpperThreshold', 8, 'Name', '', ...
        'RGBLowerThreshPos', [255, 0, 0], 'RGBUpperThreshPos', [255, 255, 0], ...
        'RGBLowerThreshNeg', [255, 0, 255], 'RGBUpperThreshNeg', [0, 0, 255], ...
        'UseRGBColor', 0, 'LUTName', '<default>', 'TransColorFactor', 1, ...
        'NrOfLags', 0, 'MinLag', 0, 'MaxLag', 0, 'CCOverlay', 0, ...
        'ClusterSize', 4, 'EnableClusterCheck', 0, 'UseValuesAboveThresh', 1, ...
        'DF1', 0, 'DF2', 0, 'ShowPositiveNegativeFlag', 3, ...
        'BonferroniValue', 0, 'NrOfFDRThresholds', 0, 'FDRThresholds', zeros(0, 3), ...
        'OverlayColors', []), 1, size(@VoxelData, 4)), ...
    'Mat44', []);
EndNewFileCode
